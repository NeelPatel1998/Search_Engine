https://www.javatpoint.com/java-flight-recorder
Java Flight Recorder - Javatpoint
Java Flight Recorder - Javatpoint ? Home Java Programs OOPs String Regex Exception Multithreading Collections JDBC Swing JavaFX Servlet JSP Spring Spring Boot Projects Interview Questions Java Training Java Tutorial What is Java History of Java Features of Java C++ vs Java Hello Java Program Program Internal How to set path? JDK, JRE and JVM JVM: Java Virtual Machine Java Variables Java Data Types Unicode System Operators Keywords Control Statements Java If-else Java Switch Java For Loop Java While Loop Java Do While Loop Java Break Java Continue Java Comments Java Programs Java Object Class Java OOPs Concepts Naming Convention Object and Class Method Constructor static keyword this keyword Java Inheritance Inheritance(IS-A) Aggregation(HAS-A) Java Polymorphism Method Overloading Method Overriding Covariant Return Type super keyword Instance Initializer block final keyword Runtime Polymorphism Dynamic Binding instanceof operator Java Abstraction Abstract class Interface Abstract vs Interface Java Encapsulation Package Access Modifiers Encapsulation Java Array Java Array Java OOPs Misc Object class Object Cloning Math class Wrapper Class Java Recursion Call By Value strictfp keyword javadoc tool Command Line Arg Object vs Class Overloading vs Overriding Java String Java Regex Exception Handling Java Inner classes Java Multithreading Java I/O Java Networking Java AWT & Events Java Swing JavaFX Java Applet Java Reflection Java Date Java Conversion Java Collection Java JDBC Java Misc Java New Features RMI Internationalization Interview Questions Java MCQ next ? ? prev Java Flight Recorder Java Flight Recorder (JFR) is a powerful performance monitoring and profiling tool. It diagnoses, collects, and monitors a running Java application on a continuous basis even in catastrophic failure. It is integrated into JVM. The tool provides a powerful GUI for application performance analysis. It is used in heavily loaded production environment applications such as profiling, black-box analysis support, and debugging. In this section, we will discuss the Java flight recorder in detail. Along with this, we will also understand its concepts, uses, architecture, JMC, and basic commands of JFR. What is Java Flight Recorder (JFR)? It was first introduced in JDK 1.7. Its functionality has been written in Java. It is an application diagnosis tool that captures both JVM and application data. The data includes garbage collection, synchronization, compiler, CPU usage, Exceptions, I/O, etc. It also provides a sampling-based profiler. With the help of a profiler, we can get accurate data and low overhead. It uses a circular buffer to store data. The above figure depicts the concept of circular flight recording buffer. New data continuously added to the buffer and old data is removed. The JFR tool cannot be used standalone. So, it is used with Java Mission Control (JMC). The JMC tool contains a plugin that allows us to visualize the data gathered by the JFR. Apart from JFR, there are some other tools provided by the JDK for monitoring and profiling: Java VisualVM JConsole Java Mission Control Diagnostic Command Tool Note that Java VisualVM was part of the Oracle and Open JDK distribution in past. Since Java 9, Java VisualVM has been removed. The following figure depicts the evolution of JFR. Note: If we want to use JFR tool in production, a commercial license is required to use. Benefits of Java Flight Recorder Similar to JFR, there are some other tools also available. But JFR has some advantages over them that are as follows: Real time analysis: It provides real-time analysis of a Java application and can be integrated with other tools. Provides enhanced data: JFR uses an articulate data model. It makes it easier to cross-reference and filter events that provide coherent data. Minimizes the ownership cost: It minimizes the cost by spending less time diagnosing and problem troubleshooting. Therefore, it minimizes the operating cost and improves system efficiency. Allows third-party event provider: JFR can also monitor the third-party applications like WebLogic Server and other products. Uses of Flight Recorder Black Box Analysis: JFR continuously adds the application information to the circular buffer. The information collected by the buffer can be accessed when an anomaly is detected to find the causes. Profiling: Profiling is a form of dynamic program analysis. It means that it measures the performance-related issue. The following two profiling is done by JFR: CPU Profiling: Profile the performance of the application. Memory Profiling: Analyze the memory of the application. The profiling information embraces garbage collection detail, memory, lock profiles, time complexity, frequency, and duration of the function call, and thread samples. The profiling information serves to aid application optimization. It improves application latency and throughput. Support and Debugging: Data collected by JFR can be essential when contacting Oracle support to help diagnose issues with your Java application. Architecture of JFR JFR architecture consists of the following things: JFR contains a runtime engine that produces the recordings. The runtime engine has two components i.e. Agent and Producers. The work of the agent is to handle the buffers, disk, and MBeans, etc. It provides a dynamic library that is written in C and Java code. Producers write up data into the buffers. The JFR plugin enables us to work with JMC. We can easily start, stop, and configure recording through GUI. JFR Components There are two main concepts of JFR i.e. Event and Dataflow. Let's briefly discuss each. JFR Events In JFR, everything is an event. It collects events that happen in the JVM along with application logs. Events represent the state of the JVM and application. The information collected by JFR is divided into two parts i.e. Header and Payload. The header includes Size, Event ID, and End Time. The payload contains the event-specific data. Besides this, it also includes Start Time, Thread ID, and Stack Trace ID but these are optional payloads. While recording events, must define the following two things: Producer: Basically, the producer is metadata and namespace for the event captures by the JFR. It is mandatory to register event type with the producer. If the producer is no longer referenced, the event type(s) will be removed. But it is a bad practice. If we want to produce a producer, just create an instance of Producer as follows: 
Producer prdcr = new Producer("Demo Producer", "It is a demo event producer.", http://www.javatpoint.com/java-tutorial/);
 Event Type: In event types, we define the metadata that is used to depict the events as well as the attributes (data) available. Event Meta Data For Event Name, Path, Description For Payload Name, Type, Description, Content-Type The content-type describes the semantics of a value. It correctly represents the value in UI. Content Type Representation Bytes 7 MB Percentage 56% Address 0x22CDA321 Millis 20ms Nanos 4567ns Therefore, events gathered extremely high-level data of an application. We should always record those events that are actually required because it minimizes the overhead. We can also filter out the events by their type, name, and duration. Types of Events JFR collects the following three types of events: Instant Event: These are the events that occur immediately. An example of an instant event is thread starts. Duration Event: These are the events that have a start and end An example of a duration event is a garbage collector. Requestable Event: These are the events whose time is configured by the user. It is logged at a regular interval. It is also known as sample events. An example of a requestable event is CPU usage every second. Creating Events We can use the following code snippet to create our own event. 
import jdk.jfr.Event;
class DemoEvent
{
}
Void perform()
{
DemoEvent de= new DemoEvent();
//event starts
de.begin();
//do important stuff
//event end
de.end();
de.commit();
}
 Let's create an event for some constants. 
import jdk.jfr.Event
class DemoEvent
{
String message;
int msgid;
}
Void perform()
{
DemoEvent de= new DemoEvent();
de.message = "Event Created";
de.msgid = 1120;
de.begin();
//code stuff
de.commit();
}
 In the above code, we can also do some additional things that provide some useful hints about the application. For this, we use annotations. JFR Annotations In the following table, we have enlisted some useful annotations. There are some other annotations that can be found in Javadoc. Annotations Description Default @Name It describes the event name. It is a class-level annotation. com.oracle.javatpoint.EventName @Label It is used to annotate fields such as variables and constants. N/A @Description It provides a detailed description (approx. 1 or 2 lines) about something. N/A @Category It specifies in which category an event belongs. N/A @Threshold It specifies the minimum duration for an event. 0ns @Enabled It controls that an event should be enabled or not. true (enabled) @StackTrace It allows us to control (enable/disable) the stack trace. true (enabled) JFR Dataflow Events gathered the data in bulk from JVM and Java applications. It collects data from both and stores it into a small thread-local buffer. Further, data is flushed into the global buffer (or in-memory) when the thread buffer is up to the neck. Similarly, when the global buffer is up to the neck, the older data is discarded. After that, the data is flushed to the repository. For this reason, its design is fast enough that does not suppress the program. The data of all events stored in flight.jfr file because disk I/O operations are more expensive. The mechanism is more complex because at the same time application might have multiple registering processes with different options. Note: It is not possible to get data at two places. It means that chunks of data will be available either on disk or in-memory (buffer), but not in both places. It avoids overlapping of data. Hence, using JFR we get more data in the JFR file than requested. Remember that data may or may not be in chronological order. The following figure depicts the dataflow of events in JFR. Running Java Flight Recorder Configuring JFR Before enabling the JFR tool ensure that you are using javac, java, JFR, JMC, and jcmd tool of the same JDK distribution. It may provide wrong data if you have installed different versions of Java. Enable JFR We know that it is a commercial feature. So, before running it, we need to unlock the commercial features. It can be unlocked by using the following flags: 
java -XX: +UnlockCommercialFeatures -XX: +FlightRecorder DemoApp
 Where DemoApp is the application name. Note: If you are using Java 11, you need not to activate its commercial features. Start JFR 
-XX: +StartFlightRecording=filename=<path>, duration=<time>
 or 
Jcmd <pid> JFR.start filename=<path> duration=<time>
 Advanced Configuration Pre-Recording Session Maximum Age of Data maxage=<time> Maximum Size to Store maxsize=<size> Global Settings (-XX: FlightRecorderOptions) Maximum Stack Trace Depth stackdepth=<n> (default 64) Save Recording on Exit dumponexit=true Logging loglevel=[ERROR|WARN|INFO|DEBUG|TRACE] Repository Path repository=<path> There are three ways to run JFR: Using JFR plugin in JMC Using Command-Line Options Using Diagnose Command Using JFR plugin in JMC We can use the JFR plugin to create a recording. It is already integrated into JMC. Follow the steps to create a recording: Right-click on JVM and select "Start Flight Recording". If it's a remote JVM, you will have to create a "JVM Connection" first. Select the type of recording: Time fixed / Continuous Select the "Event Settings" template Modify the event options for the selected flight recording template (Optional) Modify the event details (Optional) Using Command-Line Options When we use the java command to launch our application at that time, we can also enable JFR, configure it, and start recording. -XX:+|-FlightRecorder -XX:FlightRecorderOptions -XX:StartFlightRecording Note: The command-line options are available in the commercial license of JDK. If you want to use it, you need to enable it by using the following option: 
-XX:+UnlockCommercialFeatures
 Using Diagnostic Commands The following four diagnostic commands are associated with JFR: JFR.start JFR.check JFR.stop JFR.dump JFR.start: The command starts the flight recording. The following table describes the parameters that can be used with the command. Parameter Description Type of value Default name Name of recording String - settings Server-side template String - defaultrecording Starts default recording Boolean False delay Delay start of recording Time 0s duration Duration of recording Time 0s (means "forever") filename Resulting recording filename String - compression GZip compress the resulting recording file Boolean False maxage Maximum age of buffer data Time 0s (means "no age limit") maxsize Maximum size of buffers in bytes Long 0 (means "no max size") JFR.check: The command checks the running JFR recording(s). The following table lists the parameters you can use with this command. The following table describes the parameters that can be used with the command. Parameter Description Type of value Default name Recording name String - recording Recording id Long 1 verbose Print verbose data Boolean False JFR.stop: The command stops the running flight recordings. The following table describes the parameters that can be used with the command. Parameter Description Type of value Default name Recording name String - recording Recording id Long 1 discard Discards the recording data Boolean - copy_to_file Copy recording data to file String - compress_copy GZip compress "copy_to_file" destination Boolean False JFR.dump: The command copies information of flight recordings to a file. The following table describes the parameters that can be used with the command. Parameter Description Type of value Default name Recording name String - recording Recording id Long 1 copy_to_file Copy recording data to file String - compress_copy GZip compress "copy_to_file" destination Boolean False Recordings Sessions The recording session specifies exactly which information to collect. There are two pre-configured settings: default: It provides much information while minimizing the overhead. profile: It provides more information than the default. We can also configure our own setting in Mission Control. In order to use JFR, we need to activate it. We can activate it either at starting up or during the running time of the Java application. JFR provides two ways to record sessions. Using Startup Flags Using JCMD Tool Using Startup Flags The following command is used if we want to do continuous recording at startup: 
-XX: +UnlockCommercialFeatures -XX: +FlightRecorder -XX: +StartFlightRecording=delay=20s, duration=60s, name=DemoRecording, filename=C:\TEMP\ DemoRecording.jfr, settings=profile
 In the above command, the settings parameter accepts either path to or the name of a template. The templates are stored at the location jre\lib\jfr folder. If we want to get more information, change the log level as follows: 
-XX: FightRecorderOptions=loglevel=info
 Using JCMD Tool It is used if we are controlling JFR through command line. 
jcmd <pid|MainClass> <command>[parameters]
 Start Recording 
jcmd 1354 JFR.start name=DemoRecording settings=profile, delay=30s, duration=6m, filename=C:\TEMP\ DemoRecording.jfr
 Check Recording 
jcmd 1354 JFR.check
 Dump Recording 
jcmd 1354 JFR.dump name= DemoRecording filename=C:\TEMP\dump.jfr
 Unlock Commercial Feature 
jcmd 1354 VM.unlock_commercial_features
 We can also create a recording while exiting from the JVM. We need to start our application by using the following option: 
-XX:FlightRecorderOptions=defaultrecording=true,dumponexit=true,dumponexitpath=path
 Recording can also be done using triggers. A trigger is a set of rules that executes whenever a specified condition is met. If you want to use trigger to create a recording, define the trigger on the Triggers tab presented in the JMX console. At regular intervals, JFR creates checkpoints in a recording. It consists of events, constant pool, and event meta-data. It can be found in the .jfr file. Types of Recording JFR allows us to record two types of recording: Time Fixed Recording: Continuous Recording: Time Fixed Recording In time fixed recording, events are recorded for a fixed time. After that, it dumps the recording to a file. Mostly, it is used to profile a Java application for a specified time. Continuous Recording In the continuous recording, there is no fixed time for an event. Since recording continuously runs. We need to explicitly dump the recording if we want to stop it. So, when we execute the dump option, we get the most recently captured data available in the buffer. Download and Install JMC If you want to use JFR, you need to install JMC. If you are using Eclipse IDE, you can download it from the Eclipse Marketplace presented under the Help menu. Let's download and install JMC explicitly by using the following steps: Step 1: Go through the link for downloading the JMC. The link will land you on the following page. Click on the link and download JMC according to your OS. Here, we are downloading JMC for Windows. It starts downloading the jmc-7.1.2_windows-x64.zip file. Step 2: Extract the zip file and access the location jmc-7.1.2_windows-x64\bin. We get the following list of files and folders. Step 3: Open Command Prompt and execute the jmc command. Step 4: It shows a Windows Security Alert, click on the Allow access button. After that, JMC starts running. The following JMC window ensures that JMC is running successfully. JFR in Action Let's create a Java program and monitor that program in real-time. The following program sorts the random series of integers. Main.java 
import java.util.Arrays;
import java.util.Random;
import java.util.Scanner;
public class Main 
{
public static void main(String args[])
{
System.out.println("Hit any key to start running the code");
String sc=new Scanner(System.in).nextLine();
Random randomIntegers=new Random();
int array[]=new int[Integer.parseInt(args[0])];
if(args[1].equals("random"))
{
for(int i=0;i<array.length;i++)
{
array[i]=randomIntegers.nextInt(array.length);
}
Arrays.sort(array);
}
//sorts array in increasing order
if(args[1].equals("sorted"))
{
for(int i=0;i<array.length;i++)
{
array[i]=i;
}
Arrays.sort(array);
}
System.out.println("Hit any key to end the application.");
sc=new Scanner(System.in).nextLine();
}
} 
 After running the program, the program starts working when we press a key because we want to execute the program only when Flight Recording is live. In order to execute code with flight recorder, it is required to start the JFR. So, first, we will compile the above program. Starting JFR Before the application, ensure that it is profiled. There is a special way to run the application. We will use the following command to run the application. 
java -XX:+UnlockCommercialFeatures -XX:+FlightRecorder Main 10000 sorted
 In the above command, we have unlocked its commercial feature, as we have discussed above. After that, we have written the class name i.e. Main. Next to the class name, 10000 denotes the length of the array. Another argument that we have passed is mode i.e. sorted. It denotes that in what mode 10000 elements will be inserted in the array. Let's run the application. Now the application is executing. But waiting for a key hit. Note that at this moment, we will not hit any key because Flight Recorder is not started and the process ID is also not known. So, before running the program make sure that you have process ID and JFR is running. In order to know process ID, there is another command named jps. Open another Command Prompt and type the command. We see that it shows the process ID of the running application. Note that every time we run the application, we get a new process ID. Now, we will run the Flight Recorder for the process ID 8068. In order to run the recorder, we use the following command: 
jcmd 8068 JFR.start name=my_recording filename=sorted.jfr duration 120s
 In the above command, the recording name is my_recording and the file name that we will get after recording is sorted.jfr. It records the monitoring for 120s. Now Let's start the Java Mission Control. In the command prompt, type the start command that opens a new prompt window. In the new prompt window, execute the command jmc that opens the Oracle Java Mission Control. Now we can start the recording. The application can be seen with process ID in the left pane of the JMC window, as shown below. Visualize JFR Data Now we can visualize the data by accessing the .jfr file in JMC. Or we can drag and drop the application in the JMC to see the statics of the Java application. the following window represents the overview of the application. Now we can see the real-time data. If we closely look at the Processor statistics, we observe that it records the application data at every 6 seconds. You can set timestamps accordingly. Similarly, memory usage is also recorded at every 6 seconds. It also provides the information about Memory Pool. Inside it, we can do the analysis of ClassLoading, Memory, Operating System, Threading, Compilation, and many more. The following snapshot represents the thread-related information like thread count, thread connection monitoring, current thread CPU time, etc. System-related information includes connection, OS, OS architecture, VM version, etc. A detailed description of the garbage collector. It includes collection time, GC start time, GC end time, GC duration, GC ID, etc. Memory pool includes the detailed description of heap like Code Cache, Metaspace, Eden Space, Old Gen, etc. In JFR a lot of things to explore. It is too difficult to explain everything here. So, we suggest try it yourself. Here, a point to notice. Yet, the recording is not started. In order to start recording, right-click on the Flight Recorder and then click on the Start Flight Recording option, as shown below. It opens the Flight Recording dialog box. In this dialog box, we can set recording-related parameters. For example, we can provide the recording time. Here, we have specified 1 min recording. As we click on the Finish button, the recording is started. At the bottom right corner, we can see the progress of recording. When the recording is completed, it already opens in JMC, as shown below. Note: Do not close any application (like command prompt, application, eclipse, etc.) during the recording process otherwise you will get a corrupted .jfr file. The generated JFR is used to do the analysis of an application. So, it is bad practice if we close or interrupt the application during the recording process. We can also filter and sort the data for analysis. Next TopicBucket Sort in Java ? prev next ? For Videos Join Our Youtube Channel: Join Now Help Others, Please Share Learn Latest Tutorials SoapUI RPA Manual T. Cucumber Appium PostgreSQL Solr MongoDB Gimp Verilog Teradata PhoneGap Preparation Aptitude Reasoning Verbal A. Interview Company Trending Technologies AI AWS Selenium Cloud Hadoop ReactJS D. Science Angular 7 Blockchain Git ML DevOps B.Tech / MCA DBMS DS DAA OS C. Network Compiler D. COA D. Math. E. Hacking C. Graphics Software E. Web Tech. Cyber Sec. Automata C C++ Java .Net Python Programs Control S. Data Mining Javatpoint Services JavaTpoint offers too many high quality services. Mail us on hr@javatpoint.com, to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at hr@javatpoint.com. Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2018 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.
