https://www.javatpoint.com/binomial-heap
Binomial Heap - javatpoint
Binomial Heap - javatpoint ? Home Data Structure C C++ C# Java SQL HTML CSS JavaScript Ajax Android Cloud Design Pattern Quiz Projects Interview Q Comment Forum DS Tutorial DS Tutorial DS Introduction DS Algorithm Asymptotic Analysis DS Pointer DS Structure DS Array DS Array 2D Array DS Linked List Linked List Types of Linked List Singly Linked List Doubly Linked List Circular Linked List Circular Doubly List Skip list in DS DS Stack DS Stack Array Implementation Linked List Implementation DS Queue DS Queue Types of Queues Array Representation Linked List Representation Circular Queue Deque Priority Queue DS Tree DS Tree Binary Tree Binary Search Tree AVL Tree B Tree B+ Tree DS Graph DS Graph Graph Implementation BFS Algorithm DFS Algorithm Spanning Tree DS Searching Linear Search Binary Search DS Sorting Bubble Sort Bucket Sort Comb Sort Counting Sort Heap Sort Insertion Sort Merge Sort Quick Sort Radix Sort Selection Sort Shell Sort Bitonic Sort Cocktail Sort Cycle Sort Tim Sort Differences Linear vs non-linear Array vs linked list Stack vs queue Linear vs Circular Queue Linear Search vs Binary Search Singly Linked List vs Doubly Linked List Binary vs Binary Search Tree Tree vs Graph Binary Search tree vs AVL tree Red Black Tree vs AVL tree B tree vs B+ tree Quick Sort vs Merge Sort BFS vs DFS Stack vs Heap Bubble sort vs. Selection sort Misc Trie Data Structure Heap Data Structure Splay Tree Fundamental of the DS Hash Table Preorder Traversal Tree Traversal Implementation of Queue using Stacks Implementation of Stack using Queue Binomial Heap Postorder Traversal Sparse Matrix Detect loop in a Linked list Inorder Traversal Convert Infix to Postfix notation Convert infix to prefix notation Conversion of Prefix to Postfix expression Conversion of Postfix to Prefix expression DS MCQ Data Structure MCQ next ? ? prev Binomial Heap As we have already discussed about the heap data structure which is of two types, i.e., min heap and max heap. A binomial heap can be defined as the collection of binomial tree that satisfies the heap properties, i.e., min heap. The min heap is a heap in which each node has a value lesser than the value of its child nodes. To understand the binomial heap, we first understand about the binomial tree. What is Binomial tree? A Binomial tree is a tree in which Bk is an ordered tree defined recursively, where k is defined as the order of the binomial tree. If the binomial tree is represented as B0 then the tree consists of a single node. In general terms, Bk consists of two binomial trees, i.e., Bk-1 and Bk-1 are linked together in which one tree becomes the left subtree of another binomial tree. It can be represented as: Let's understand through examples. If B0, where k is 0, means that there would exist only one node in the tree shown as below: If B1, where k is 1, means k-1 equal to 0. Therefore, there would be two binomial trees of B0 in which one B0 becomes the left subtree of another B0. If B2, where k is 2, means k-1 equal to 1. Therefore, there would be two binomial trees of B1 in which one B1 becomes the left subtree of another B1. If B3 , where k is 3, means k-1 equal to 2. Therefore, there would be two binomial trees of B3 in which one B3 becomes the left subtree of another B3.] Properties of Binomial tree There are 2k If k=1 then 20 = 1. The number of nodes is 1. If k = 2 then 21 = 2. The number of nodes is 2. The height of the tree is k. If k=0 then the height of the tree would be 0. If k=1 then the height of the tree would be 1. There are exactly kci or k/i nodes at depth i = 0, 1..k. For example, if k is equal to 4 and at depth i=2, we have to determine the number of nodes. Binomial Heap A binomial heap is a collection of binomial trees that satisfies the properties of a min- heap. The following are the two properties of the binomial heap: Each binomial heap obeys the min-heap properties. For any non-negative integer k, there should be atleast one binomial tree in a heap where root has degree k. Let's understand the above two properties through an example. The above figure has three binomial trees, i.e., B0, B2, B3. The above all three binomial trees satisfy the min heap's property as all the nodes have a smaller value than the child nodes. The above figure also satisfies the second property of the binomial heap. For example, if we consider the value of k as 3, then we can observe in the above figure that the binomial tree of degree 3 exists in the heap. Representation of Binomial heap node The above figure shows the representation of the binomial heap node in the memory. The first block in the memory contains the pointer that stores the address of the parent of the node. The second block stores the key value of the node. The third block contains the degree of the node. The fourth block is divided into two parts, i.e., left child and sibling. The left child contains the address of the left child of a node, whereas the sibling contains the address of the sibling. Important point If we want to create the binomial heap of 'n' nodes, that can be simply defined by the binary number of 'n'. For example: if we want to create the binomial heap of 13 nodes; the binary form of 13 is 1101, so if we start the numbering from the rightmost digit, then we can observe that 1 is available at the 0, 2, and 3 positions; therefore, the binomial heap with 13 nodes will have B0, B2, and B3 binomial trees. Let's consider another example. If we want to create the binomial heap of 9 nodes. The binary form of 9 is 1001. As we can observe in the binary number that 1 digit is available at 0 and 3 position; therefore, the binomial heap will contain the binomial trees of 0 and 3 degree. Operations on Binomial Heap Creating a new binomial heap: When we create a new binomial heap then it simply takes O(1) time because creating a heap will create the head of the heap in which no elements are attached. Finding the minimum key: As we know that binomial heap is a collection of binomial trees and each binomial tree satisfies the property of min heap means root node contains the minimum value. Therefore, we need to compare only root node of all the binomial trees to find the minimum key. The time complexity for finding a minimum key is O(logn). Union of two binomial heap: If we want to combine two binomial heaps, then we can simply find the union of two binomial heaps. The time complexity for finding a union is O(logn). Inserting a node: The time complexity for inserting a node is O(logn). Extracting minimum key: The time complexity for removing a minimum key is O(logn). Decreasing a key: When the key value of any node is changed, then the binomial tree does not satisfy the min-heap. We need to perform some rearrangements in order to satisfy the min-heap property. The time complexity would be O(logn). Deleting a node: The time complexity for deleting a node is O(logn). Union of two Binomial Heap To perform the union to two binomial heap, we will use the following cases: Case 1: If degree[x] is not equal to degree[next x] then move pointer ahead. Case 2: if degree[x] = degree[next x] = degree[sibling(next x)] then Move pointer ahead. Case 3: If degree[x] = degree[next x] but not equal to degree[sibling[next x]] and key[x] < key[next x] then remove [next x] from root and attached to x. Case 4: If degree[x] = degree[next x] but not equal to degree[sibling[next x]] and key[x] > key[next x] then remove x from root and attached to [next x]. Let's understand the union of two binomial heaps through an example. As we can observe in the above figure that there are two binomial heaps. First, we combine these two binomial heaps. To combine these two binomial heaps, we need to arrange them in the increasing order of binomial trees shown as below: Initially, x points to the B0 having value 12, and next[x] points to B0 having value 18. The B1 is the sibling of B0 having node value 18. Therefore, the sibling B1 is represented as sibling[next x]. Now, we will apply case 1. Case 1 says that 'if degree[x] is not equal to degree[next x] then move pointer ahead' but in the above example, the degree of x is the same as the degree of next x, so this case is not valid. Now we will apply case 2. The case 2 says that 'if degree[x] = degree[next x] = degree[sibling(next x)] then Move pointer ahead'. In the above example, the degree of x is same as the degree of the next x but not equal to the degree of a sibling of next x; therefore, this case is not valid. Now we will apply case 3. The case 3 says that 'If degree[x] = degree[next x] but not equal to degree[sibling[next x] and key[x] < key[next x] then remove [next x] from root and attached to x'. In the above example, the degree of x is equal to the degree of next x but equal to the degree of a sibling of next x, and the key value of x, i.e., 12, is less than the value of next x, i.e., 18; therefore, this case is valid. So, we have to remove the next x, i.e., 18, from the root and attach it to the x, i.e., 12, shown as below: As we can observe in the above binomial heap that node 18 is attached to the node 12. Now we will reapply the cases in the above binomial heap. First, we will apply case 1. Since x is pointing to node 12 and next x is pointing to node 7, the degree of x is equal to the degree of next x; therefore, case 1 is not valid. Now we will apply case 2. Since the degree of x is equal to the degree of next x and also equal to the degree of sibling of next x; therefore, this case is valid. We will move the pointer ahead shown as below: As we can observe in the above figure that 'x' points to the binomial tree having root node 7, next(x) points to the binomial tree having root node 3 while prev(x) points to the binomial tree having root node 12. The sibling(next(x)) points to the binomial tree having root node 15. Now we will apply case 3 in the above tree. Since the degree of x is equal to the degree of next x, i.e., 1 but not equal to the degree of a sibling of next x, i.e., 2. Either case 3 or case 4 is valid based on the second condition. The key value of x, i.e., 7 is greater than the key value of next(x), i.e., 3; therefore, we can say that case 4 is valid. Here, we need to remove the x and attach it to the next(x) shown as below: As we can observe in the above figure that x becomes the left child of next(x). The pointer also gets updated. Now, x will point to the binomial tree having root node 3, and degree is also changed to 2. The next(x) points to the binomial tree having root node as 15, and the sibling(next(x)) will point to the binomial tree having root node as 6. In the above tree, the degree of x, i.e., B2, is the same as the degree of next(x), i.e., B2, but not equal to the degree of sibling(next(x)), i.e., B4. Therefore, either case 3 or case 4 is valid based on the second condition. Since the key value of x is less than the value of next(x) so we need to remove next(x) and attach it to the x shown as below: As we can observe in the above figure that next(x) becomes the left child of x, and the degree of x also gets changed to B3. The pointer next(x) also gets updated, and it now points to the binomial tree having root node 6. The degree of x is 3, and the degree of next(x) is 4. Since the degrees of x and next(x) are not equal, so case 1 is valid. We will move the pointer ahead, and now x points to node 6. The B4 is the last binomial tree in a heap, so it leads to the termination of the loop. The above tree is the final tree after the union of two binomial heaps. Inserting a new node in a Binomial heap Now we will see how to insert a new node in a heap. Consider the below heap, and we want to insert a node 15 in a heap. In the above heap, there are three binomial trees of degree B0, B1, and B2, where B0 is attached to the head of the heap. Let's assume that node 15 is attached to the head of the heap shown as below: First, we will combine these two heaps. As the degree of node 12 and node 15 is B0 so node 15 is attached to the node 12 shown in the above figure. Now we assign 'x' to the B0 having key value 12, next(x) to the B0 having key value 15, and sibling(next(x)) to the B1 having key value 7. Since the degree of x is equal to the degree of next(x) but not equal to the degree of sibling of next(x) so either case 3 or case 4 will be applied to the heap. The key value of x is greater than the key value of next(x); therefore, next(x) would be removed and attached it to the x. Now, we will reapply the cases in the above heap. Now, x points to the node 12 having degree B1, next(x) points to the node 7 having degree B1 and sibling(next(x)) points to the node 15 having degree B2. Since the degree of x is same as the degree of next(x) but not equal to the degree of sibling of next(x), so either case 3 or case 4 is applied. The key value of x is greater than the key value of next(x); therefore, the x is removed and attached to the x shown as below: As we can observe in the above figure that when 'x' is attached to the next(x) then the degree of node 7 is changed to B2. The pointers are also get updated. Now 'x' points to the node 7 and next(x) points to the node 15. Now we will reapply the cases in the above heap. Since the degree of x is equal to the degree of next(x) and the key value of x is less than the key value of next(x); therefore, next(x) would be removed from the heap and attached it to the x shown as below: As we can observe in the above heap that the degree of x gets changed to 3, and this is the final binomial heap after inserting the node 15. Extracting a minimum key Here extracting a minimum key means that we need to remove the element which has minimum key value. We already know that in min heap, the root element contains the minimum key value. Therefore, we have to compare the key value of root node of all the binomial trees. Consider the binomial heap which is given below: In the above heap, the key values of root node of all the binomial trees are 12, 7 and 15. The key value 7 is the minimum value so we will remove the node 7 from the tree shown as below: As we can observe in the above binomial heap that the degree of node 12 is B0, degree of node 25 is B0, and degree of node 15 is B2. The pointer x points to the node 12, next(x) points to the node 25, and sibling(next(x)) points to the node 15. Since the degree of x is equal to the degree of next(x) but not equal to the degree of sibling(next(x)); therefore, either case 3 or case 4 will be applied to the above heap. The key value of x is less than the key value of next(x), so node 25 will be removed and attached to the node 12 shown as below: The degree of node 12 is also changed to 1. Decreasing a key Now we will see how to decrease a key with the help of an example. Consider the below heap, and we will decrease the key 45 by 7: After decreasing the key by 7, the heap would look like: Since the above heap does not satisfy the min-heap property, element 7 will be compared with an element 30; since the element 7 is less than the element 30 so 7 will be swapped with 30 element shown as below: Now we will again compare element 7 with its root element, i.e., 8. Since element 7 is less than element 8 so element 7 will be swapped with an element 8 shown as below: Now, the above heap satisfies the property of the min-heap. Deleting a node Now we will see how to delete a node with the help of an example. Consider the below heap, and we want to delete node 41: First, we replace node 41 with the smallest value, and the smallest value is -infinity, shown as below: Now we will swap the -infinity with the root node of the tree shown as below: The next step is to extract the minimum key. Since the minimum key in a heap is -infinity so we will extract this key, and the heap would be: Next TopicPostorder Traversal ? prev next ? For Videos Join Our Youtube Channel: Join Now Help Others, Please Share Learn Latest Tutorials SoapUI RPA Manual T. Cucumber Appium PostgreSQL Solr MongoDB Gimp Verilog Teradata PhoneGap Preparation Aptitude Reasoning Verbal A. Interview Company Trending Technologies AI AWS Selenium Cloud Hadoop ReactJS D. Science Angular 7 Blockchain Git ML DevOps B.Tech / MCA DBMS DS DAA OS C. Network Compiler D. COA D. Math. E. Hacking C. Graphics Software E. Web Tech. Cyber Sec. Automata C C++ Java .Net Python Programs Control S. Data Mining Javatpoint Services JavaTpoint offers too many high quality services. Mail us on hr@javatpoint.com, to get more information about given services. Website Designing Website Development Java Development PHP Development WordPress Graphic Designing Logo Digital Marketing On Page and Off Page SEO PPC Content Development Corporate Training Classroom and Online Training Data Entry Training For College Campus JavaTpoint offers college campus training on Core Java, Advance Java, .Net, Android, Hadoop, PHP, Web Technology and Python. Please mail your requirement at hr@javatpoint.com. Duration: 1 week to 2 week Like/Subscribe us for latest updates or newsletter Learn TutorialsLearn JavaLearn Data StructuresLearn C ProgrammingLearn C++ TutorialLearn C# TutorialLearn PHP TutorialLearn HTML TutorialLearn JavaScript TutorialLearn jQuery TutorialLearn Spring Tutorial Our WebsitesJavatpoint.comHindi100.comLyricsia.comQuoteperson.comJobandplacement.com Our Services Website Development Android Development Website Designing Digital Marketing Summer Training Industrial Training College Campus Training Contact Address: G-13, 2nd Floor, Sec-3 Noida, UP, 201301, India Contact No: 0120-4256464, 9990449935Contact Us Subscribe Us Privacy PolicySitemap About Me © Copyright 2011-2018 www.javatpoint.com. All rights reserved. Developed by JavaTpoint.
